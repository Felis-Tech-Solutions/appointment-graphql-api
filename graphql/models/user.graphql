type User {
    id: ID!
    name: String!
    email: String!
    emailVerifiedAt:    DateTime @rename(attribute: "email_verified_at")
    createdAt:          DateTime @rename(attribute: "created_at")
    updatedAt:          DateTime @rename(attribute: "updated_at")
    deletedAt:          DateTime @rename(attribute: "deleted_at")
    groups:             [Group!]! @belongsToMany
}

extend type Query{
    user(
        id:      ID      @eq @rules(apply: ["prohibits:email", "required_without:email"])
        trashed: Trashed @trashed,
        email:   Email   @eq @rules(apply: ["prohibits:id", "required_without:id", "email"])
    ): User              @find

    users(
        trashed:       Trashed   @trashed,
        id:            [ID!]     @in(key: "id")     @rules(apply: ["prohibits:email"])
        email:         [Email!]  @in(key: "email")  @rules(apply: ["prohibits:id", "email"])
        name:          String    @like
        emailVerified: Boolean   @scope
        role:          [String!] @scope
        orderBy:       _         @orderBy(columns:["id", "name", "email", "created_at", "updated_at"])
    ): [User!]! @paginate

    me: User @auth

    allUsers: [User!]! @all
}

extend type Mutation {
    createUser(input: UserCreateInput! @spread): User @create
    updateUser(input: UserUpdateInput! @spread): User @update
    deleteUser(id: ID! @whereKey): User @delete
    restoreUser(id: ID! @whereKey): User @restore
}

input UserCreateInput @validator {
    name:                 String!
    email:                Email!
    password:             String!
}

input UserUpdateInput @validator {
    id:                      ID!
    name:                    String
    email:                   Email
    currentPassword:         String @drop
    newPassword:             String @rename(attribute: "password") @hash
    newPasswordConfirmation: String @drop
    groups:                  UpdateGroupBelongsToManyInput
}

input UpdateUserBelongsToManyInput {
    connect:                [ID!]
    sync:                   [ID!]
    syncWithoutDetaching:   [ID!]
    disconnect:             [ID!]
}
